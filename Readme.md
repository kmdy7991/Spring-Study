# Spring

-   Java (객체 지향) 기반 Framework
-   객체 지향 애플리케이션을 개발할 수 있다.

### POJO (Plain Old Java Object)

Java로 생성하는 순수한 객체
<br>
객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고, 필요에 따라 재사용할 수 있는 방식으로 설계된 Object

### 객체 지향 프로그래밍

프로그램을 명령어 단위가 아닌 여러개의 독립된 단위로 표현하는 것.
<br>
프로그램을 유연하고 변경이 용이하다.

### 다형성

어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 성질을 가질 수 있는 것

장점
<br>
역할과 구현을 분리하여 유연하고, 변경이 용이하다.
확장 가능한 설계를 할 수 있고 변경이 Client에 영향을 주지 않는다.
<br>
단점
<br>
역할의 변경은 Client와 Server 큰 영향을 끼치며, 구현의 복잡성이 증가한다.
<br>

Java의 다형성

-   역할 = Interface
-   구현 - Interface의 구현체
-   Overriding - 다형성으로 Interface를 구현한
    객체를 실행시점에 변경할 수 있음

### SOLID

#### SRP (Single Responsibility Principle) - 단일 책임 원칙

하나의 클래스는 하나의 책임만 갖는다.
<br>
하나의 책임은 모호한 표현 -> 변경을 기준으로 변경이 있을 때 파급 효과가 적다면 단일 책임 원칙을 잘 따른 것

#### OCP (Open Close Principle) - 개방-폐쇄 원칙

확장에는 열려 있으나, 변경에는 닫혀 있어야한다.
<br>
다형성을 활용하여 구현

문제점
<br> 구현체의 변경 시 Client 코드가 변경됨
<br> 객체의 생성, 연관관계를 맺는 별도의 조립, 설정자 필요

#### LSP (Liskov Substitution Principle) - 리스코프 치환 원칙

프로그램의 객체는 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
<br>
다형성에서 하위 클래스는 Interface 규약을 다 지켜야 한다.

#### ISP (Interface Segregation Principle) - 인터페이스 분리 원칙

특정 Client를 위한 Interface 여러 개가 범용 Interface 하나보다 낫다.
<br>
Ex. Car Interface -> Drive, Management Interface
<br>
Interface가 명확해지며, 대체 가능성이 높아진다.

#### DIP (Dependency Inversion Principle) - 의존 관계 역전 원칙

프로그래머는 추상화에 의존하고, 구체화에 의존하면 안된다.
<br>
구현 클래스가 아닌 Interface에 의존해야함
<br>
구현체에 의존하면 변경이 어려워 진다.

### 다형성만으로 OCP와 DIP를 지킬 수 없음 -> Spring Container와 DI

### Spring

#### Bean Factory

-   스프링 컨테이너의 최상위 인터페이스
-   스프링 빈을 관리하고 조회하는 역할
-   getBean() method 제공

#### ApplicationContext

-   BeanFactory 기능을 모두 상속받아서 제공
-   추가적인 부가기능을 제공(메세지 소스를 활용한 국제화, 환경변수, 애플리케이션 이벤트, 편리한 리소스 조회)

#### 다양한 설정 형식 지원 - Java Code, XML

-   Annotation 기반 Java code 설정

-   XML 설정 사용
    <br>
    XML 사용 시 컴파일 없이 빈 설정 정보를 변경할 수 있다.
    GenericXmlApplicationContext에 xml 설정 파일을 제공

#### BeanDefinition

-   BeanDefinition이라는 추상화를 통해 다양한 설정 정보를 제공
-   BeanDefinition을 빈 설정 메타 정보라 한다.

### 웹 어플리케이션과 싱글톤

-   웹 어플리케이션은 보통 여러 고객이 동시에 요청을 한다.
-   스프링이 없는 순수한 DI 컨테이너는 요청마다 객체를 새로 생성하고, 이는 리소스 낭비가 심하다.
-   이를 해결하기위해 1개의 객체만 생성하고 요청마다 해당 객체를 통해 요청을 처리한다. -> 싱글톤

#### 싱글톤 패턴

인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴

단점
싱글톤 패턴을 구현하는 코드량이 많아진다.
클라이언트가 구체 클래스에 의존한다.
private 생성자로 자식 클래스를 만들기 어렵다.
결론적으로 유연성이 떨어지며, SOLID를 위반한다.

#### 싱글톤 컨테이너

-   스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
-   스프링 컨테이너는 싱글톤 컨테이너 역할을하고, 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
-   스프링 컨테이너를 통해 OCP, DIP, private 생성자로 발생하는 제약을 상쇄할 수 있다.
-   스프링의 기본 빈 등록 방식은 싱긅톤이지만, 요청마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.

주의점

-   싱글톤은 클라이언트에서 객체를 공유하여 사용하기 때문에
-   무상태로 설계해야한다.
    -   특정 클라이언트에 의존적인 필드가 있으면 안되고, 값을 변경할 수 있는 필드가 있으면 안된다.
    -   가급적 읽기만 가능해야하고, 필드 대신 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.

#### @Configuration, CGLIB

-   클래스에 @Configuration을 명시하면 바이트 코드를 조작하는 CGLIB을 사용해 싱글톤을 보장한다.
-   @Bean이 명시된 메서드마다 스프링 빈이 존재하면 존재하는 빈이 반환되고, 아니라면 생성해서 빈으로 등록하고 반환다는 코드가 동적으로 생성된다. 이를 통해 싱글톤을 보장한다.

### 컴포넌트 스캔과 의존관계 자동 주입

#### @ComponentScan

-   @Component가 붙은 모든 클래스를 스프링 빈으로 등록한다. 이떄 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자는 소문자로 사용한다.

#### @Autowired

-   생성자에 @Autowired를 지정하면 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다. 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.

#### Filter

-   ComponentScan에 includeFilters와 excludeFilters를 통해 스프링 빈에 등록 여부를 지정할 수 있다.
-   Filter Type은 5가지 옵션이 있다.
    -   ANNOTATION: 기본값, 어노테이션을 인식해서 동작한다.
    -   ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
    -   ASPECTJ: AspectJ 패턴 사용
    -   REGEX: 정규식 사용
    -   CUSTOM: TypeFilter 라는 인터페이스를 구현해서 처리한다.

#### 중복 등록과 충돌

컴포넌트 스캔에서 같은 빈 이름이 등록될 때

-   자동 빈 등록 VS 자동 빈 등록
    -   ConflictingBeanDefinitionException 예외 발생
-   수동 빈 등록 VS 자동 빈 등록
    -   수동으로 등록한 빈이 우선권을 갖는다.(수동 빈이 자동 빈을 오버라이딩 한다.)
    -   최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값이 바뀌었다.

### 의존관계 주입

-   생성자 주입
    -   생성자를 통해서 생성자 호출 시점에 의존관계가 주입된다.
    -   불변, 필수 의존관계에 사용된다.
-   수정자 주입
    -   setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해 의존관계를 주입한다.
    -   선택, 변경 가능성이 있는 의존관계에 사용
    -   자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법
-   필드 주입
    -   필드에 바로 주입하는 방법
    -   코드가 간결하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다.
    -   DI 프레임워크가 없으면 아무것도 할 수 없다.
-   일반 메서드 주입
    -   일반 메서드를 통해 주입 받을 수 있다.
    -   한번에 여러 필드를 주입 받을 수 있다.

#### 자동 주입 옵션 처리

-   @Autowired(required = false)
    자동 주입 대상이 없으면 메서드 호출이 되지 않음
-   @Nullable
    자동 주입 대상이 없으면, null이 입력된다.
-   Optional<>
    자동 주입 대상이 없으면 Optional.empty가 입력된다.

위 3가지 방법으로 빈이 없더라도 동작할 수 있다.

#### 생성자 주입을 선택하자

스프링을 포함한 DI 프레임워크의 대부분이 생성자 주입을 권장한다.

-   대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 애플리케이션 종료시점까지 불변해야한다.
-   수정자 주입을 사용하면 setter 메서드를 public으로 열어두어야 한다.
-   실수로 변경할 수 있고, 변경되면 안되는 의존관계에서 변경 가능성이 생기므로 좋은 설계가 아니다.
-   생성자 주입은 객체 생성 시점에서 딱 1번만 호출되므로 이후 호출이 없어 불변성을 유지할 수 있다.

#### 조회 빈 타입이 2개 이상일때
@Autowired는 타입으로 빈을 찾아온다.
같은 타입의 빈이 2개이상 존재한다면 @Autowired는 어떤 타입을 주입해야 하는지 알수 없다. 하위 타입을 명시하면 DIP를 위반하여 유연성이 떨어진다.

해결
- @Autowired 필드명 매칭
@Autowired는 타입 매칭 이후 같은 타입이 여러개라면 필드명으로 빈 이름을 매칭한다. 즉, 인터페이스의 구현체의 이름을 변수명으로 지정하면 해당 구현체를 주입시킨다.
- @Quilifier
@Quilifier 끼리 매칭하고 이후 빈 이름을 매칭한다. 이후 빈이 없다면 예외가 발생한다.
주입시 @Quilifier를 명시하고 옵션으로 구현체의 이름을 작성한다.
- @Primary
@Primary 어노테이션이 붙은 빈이 의존관계 주입의 우선권을 갖는다.

- 우선순위
@Primry는 기본 값처럼 동작하는 것이고, @Quilifier는 매우 상세하게 동작한다. 스프링은 자동보다 수동이, 넓은 범위의 선택권보다 좁은 범위의 선택권이 우선순위가 높다. 따라서 @Quilifier의 우선순위가 더 높다.